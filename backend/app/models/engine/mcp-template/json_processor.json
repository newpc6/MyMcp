{
  "name": "json_processor",
  "description": "JSON数据处理工具模块",
  "module_path": "repository.json_processor",
  "author": "系统",
  "version": "1.0.0",
  "tags": "JSON,数据处理,格式化,验证",
  "icon": "code",
  "is_hosted": true,
  "category": "数据处理工具",
  "config_schema": null,
  "code": "\"\"\"\nJSON数据处理工具模块，提供JSON数据的各种处理功能\n\"\"\"\nimport json\nimport jsonschema\nfrom typing import Dict, Any, List, Optional, Union\nfrom jsonpath_ng import parse as jsonpath_parse\nimport re\n\ndef validate_json(json_string: str) -> Dict[str, Any]:\n    \"\"\"\n    验证JSON字符串的有效性\n    \n    参数:\n        json_string: 要验证的JSON字符串\n        \n    返回:\n        验证结果\n    \"\"\"\n    try:\n        parsed_data = json.loads(json_string)\n        return {\n            \"valid\": True,\n            \"data\": parsed_data,\n            \"type\": type(parsed_data).__name__,\n            \"size\": len(json_string)\n        }\n    except json.JSONDecodeError as e:\n        return {\n            \"valid\": False,\n            \"error\": str(e),\n            \"line\": e.lineno,\n            \"column\": e.colno,\n            \"position\": e.pos\n        }\n    except Exception as e:\n        return {\n            \"valid\": False,\n            \"error\": str(e)\n        }\n\ndef format_json(json_string: str, indent: int = 2, sort_keys: bool = False) -> Dict[str, Any]:\n    \"\"\"\n    格式化JSON字符串\n    \n    参数:\n        json_string: 要格式化的JSON字符串\n        indent: 缩进空格数\n        sort_keys: 是否排序键名\n        \n    返回:\n        格式化结果\n    \"\"\"\n    try:\n        data = json.loads(json_string)\n        formatted = json.dumps(data, indent=indent, sort_keys=sort_keys, ensure_ascii=False)\n        \n        return {\n            \"original\": json_string,\n            \"formatted\": formatted,\n            \"original_size\": len(json_string),\n            \"formatted_size\": len(formatted),\n            \"success\": True\n        }\n    except json.JSONDecodeError as e:\n        return {\n            \"error\": f\"JSON格式错误: {str(e)}\",\n            \"success\": False\n        }\n    except Exception as e:\n        return {\n            \"error\": str(e),\n            \"success\": False\n        }\n\ndef minify_json(json_string: str) -> Dict[str, Any]:\n    \"\"\"\n    压缩JSON字符串（移除空格和换行）\n    \n    参数:\n        json_string: 要压缩的JSON字符串\n        \n    返回:\n        压缩结果\n    \"\"\"\n    try:\n        data = json.loads(json_string)\n        minified = json.dumps(data, separators=(',', ':'), ensure_ascii=False)\n        \n        return {\n            \"original\": json_string,\n            \"minified\": minified,\n            \"original_size\": len(json_string),\n            \"minified_size\": len(minified),\n            \"compression_ratio\": round((1 - len(minified) / len(json_string)) * 100, 2),\n            \"success\": True\n        }\n    except json.JSONDecodeError as e:\n        return {\n            \"error\": f\"JSON格式错误: {str(e)}\",\n            \"success\": False\n        }\n    except Exception as e:\n        return {\n            \"error\": str(e),\n            \"success\": False\n        }\n\ndef extract_values(json_string: str, json_path: str) -> Dict[str, Any]:\n    \"\"\"\n    使用JSONPath提取JSON中的值\n    \n    参数:\n        json_string: JSON字符串\n        json_path: JSONPath表达式\n        \n    返回:\n        提取结果\n    \"\"\"\n    try:\n        data = json.loads(json_string)\n        jsonpath_expr = jsonpath_parse(json_path)\n        matches = [match.value for match in jsonpath_expr.find(data)]\n        \n        return {\n            \"json_path\": json_path,\n            \"matches\": matches,\n            \"count\": len(matches),\n            \"success\": True\n        }\n    except json.JSONDecodeError as e:\n        return {\n            \"error\": f\"JSON格式错误: {str(e)}\",\n            \"success\": False\n        }\n    except Exception as e:\n        return {\n            \"error\": f\"JSONPath错误: {str(e)}\",\n            \"success\": False\n        }\n\ndef merge_json(json1: str, json2: str, strategy: str = \"update\") -> Dict[str, Any]:\n    \"\"\"\n    合并两个JSON对象\n    \n    参数:\n        json1: 第一个JSON字符串\n        json2: 第二个JSON字符串\n        strategy: 合并策略 (update, deep_merge)\n        \n    返回:\n        合并结果\n    \"\"\"\n    try:\n        data1 = json.loads(json1)\n        data2 = json.loads(json2)\n        \n        if not isinstance(data1, dict) or not isinstance(data2, dict):\n            return {\n                \"error\": \"只能合并JSON对象（字典类型）\",\n                \"success\": False\n            }\n        \n        if strategy == \"update\":\n            merged = {**data1, **data2}\n        elif strategy == \"deep_merge\":\n            merged = _deep_merge(data1, data2)\n        else:\n            return {\n                \"error\": f\"不支持的合并策略: {strategy}\",\n                \"success\": False\n            }\n        \n        return {\n            \"merged\": merged,\n            \"merged_json\": json.dumps(merged, indent=2, ensure_ascii=False),\n            \"strategy\": strategy,\n            \"success\": True\n        }\n    except json.JSONDecodeError as e:\n        return {\n            \"error\": f\"JSON格式错误: {str(e)}\",\n            \"success\": False\n        }\n    except Exception as e:\n        return {\n            \"error\": str(e),\n            \"success\": False\n        }\n\ndef _deep_merge(dict1: dict, dict2: dict) -> dict:\n    \"\"\"深度合并两个字典\"\"\"\n    result = dict1.copy()\n    \n    for key, value in dict2.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = _deep_merge(result[key], value)\n        else:\n            result[key] = value\n    \n    return result\n\ndef compare_json(json1: str, json2: str) -> Dict[str, Any]:\n    \"\"\"\n    比较两个JSON对象的差异\n    \n    参数:\n        json1: 第一个JSON字符串\n        json2: 第二个JSON字符串\n        \n    返回:\n        比较结果\n    \"\"\"\n    try:\n        data1 = json.loads(json1)\n        data2 = json.loads(json2)\n        \n        differences = _find_differences(data1, data2)\n        \n        return {\n            \"equal\": len(differences) == 0,\n            \"differences\": differences,\n            \"difference_count\": len(differences),\n            \"success\": True\n        }\n    except json.JSONDecodeError as e:\n        return {\n            \"error\": f\"JSON格式错误: {str(e)}\",\n            \"success\": False\n        }\n    except Exception as e:\n        return {\n            \"error\": str(e),\n            \"success\": False\n        }\n\ndef _find_differences(obj1: Any, obj2: Any, path: str = \"\") -> List[Dict[str, Any]]:\n    \"\"\"递归查找两个对象的差异\"\"\"\n    differences = []\n    \n    if type(obj1) != type(obj2):\n        differences.append({\n            \"path\": path,\n            \"type\": \"type_mismatch\",\n            \"value1\": obj1,\n            \"value2\": obj2,\n            \"type1\": type(obj1).__name__,\n            \"type2\": type(obj2).__name__\n        })\n        return differences\n    \n    if isinstance(obj1, dict):\n        all_keys = set(obj1.keys()) | set(obj2.keys())\n        for key in all_keys:\n            new_path = f\"{path}.{key}\" if path else key\n            \n            if key not in obj1:\n                differences.append({\n                    \"path\": new_path,\n                    \"type\": \"missing_in_first\",\n                    \"value2\": obj2[key]\n                })\n            elif key not in obj2:\n                differences.append({\n                    \"path\": new_path,\n                    \"type\": \"missing_in_second\",\n                    \"value1\": obj1[key]\n                })\n            else:\n                differences.extend(_find_differences(obj1[key], obj2[key], new_path))\n    \n    elif isinstance(obj1, list):\n        max_len = max(len(obj1), len(obj2))\n        for i in range(max_len):\n            new_path = f\"{path}[{i}]\" if path else f\"[{i}]\"\n            \n            if i >= len(obj1):\n                differences.append({\n                    \"path\": new_path,\n                    \"type\": \"missing_in_first\",\n                    \"value2\": obj2[i]\n                })\n            elif i >= len(obj2):\n                differences.append({\n                    \"path\": new_path,\n                    \"type\": \"missing_in_second\",\n                    \"value1\": obj1[i]\n                })\n            else:\n                differences.extend(_find_differences(obj1[i], obj2[i], new_path))\n    \n    else:\n        if obj1 != obj2:\n            differences.append({\n                \"path\": path,\n                \"type\": \"value_mismatch\",\n                \"value1\": obj1,\n                \"value2\": obj2\n            })\n    \n    return differences\n\ndef analyze_json_structure(json_string: str) -> Dict[str, Any]:\n    \"\"\"\n    分析JSON数据结构\n    \n    参数:\n        json_string: 要分析的JSON字符串\n        \n    返回:\n        结构分析结果\n    \"\"\"\n    try:\n        data = json.loads(json_string)\n        analysis = _analyze_structure(data)\n        \n        return {\n            \"structure\": analysis,\n            \"total_keys\": _count_keys(data),\n            \"max_depth\": _calculate_depth(data),\n            \"data_types\": _get_data_types(data),\n            \"success\": True\n        }\n    except json.JSONDecodeError as e:\n        return {\n            \"error\": f\"JSON格式错误: {str(e)}\",\n            \"success\": False\n        }\n    except Exception as e:\n        return {\n            \"error\": str(e),\n            \"success\": False\n        }\n\ndef _analyze_structure(obj: Any, path: str = \"\") -> Dict[str, Any]:\n    \"\"\"分析对象结构\"\"\"\n    if isinstance(obj, dict):\n        return {\n            \"type\": \"object\",\n            \"keys\": list(obj.keys()),\n            \"key_count\": len(obj),\n            \"children\": {k: _analyze_structure(v, f\"{path}.{k}\" if path else k) for k, v in obj.items()}\n        }\n    elif isinstance(obj, list):\n        return {\n            \"type\": \"array\",\n            \"length\": len(obj),\n            \"item_types\": list(set(type(item).__name__ for item in obj)),\n            \"sample_items\": [_analyze_structure(item, f\"{path}[{i}]\") for i, item in enumerate(obj[:3])]\n        }\n    else:\n        return {\n            \"type\": type(obj).__name__,\n            \"value\": obj if len(str(obj)) < 100 else str(obj)[:100] + \"...\"\n        }\n\ndef _count_keys(obj: Any) -> int:\n    \"\"\"递归计算所有键的数量\"\"\"\n    if isinstance(obj, dict):\n        return len(obj) + sum(_count_keys(v) for v in obj.values())\n    elif isinstance(obj, list):\n        return sum(_count_keys(item) for item in obj)\n    else:\n        return 0\n\ndef _calculate_depth(obj: Any) -> int:\n    \"\"\"计算JSON的最大深度\"\"\"\n    if isinstance(obj, dict):\n        return 1 + max((_calculate_depth(v) for v in obj.values()), default=0)\n    elif isinstance(obj, list):\n        return 1 + max((_calculate_depth(item) for item in obj), default=0)\n    else:\n        return 0\n\ndef _get_data_types(obj: Any) -> Dict[str, int]:\n    \"\"\"统计数据类型\"\"\"\n    types = {}\n    \n    def count_types(item):\n        type_name = type(item).__name__\n        types[type_name] = types.get(type_name, 0) + 1\n        \n        if isinstance(item, dict):\n            for v in item.values():\n                count_types(v)\n        elif isinstance(item, list):\n            for v in item:\n                count_types(v)\n    \n    count_types(obj)\n    return types",
  "markdown_docs": "# JSON处理工具\n\n## 简介\nJSON处理工具模块提供全面的JSON数据处理功能，包括验证、格式化、压缩、提取、合并、比较和结构分析等。\n\n## 功能列表\n\n### 1. JSON验证\n验证JSON字符串的有效性和格式正确性。\n\n**参数：**\n- json_string: 要验证的JSON字符串\n\n**返回：**\n- 验证结果，包括是否有效、解析后的数据、类型和大小信息\n\n### 2. JSON格式化\n美化JSON字符串，添加适当的缩进和换行。\n\n**参数：**\n- json_string: 要格式化的JSON字符串\n- indent: 缩进空格数，默认为2\n- sort_keys: 是否排序键名，默认为False\n\n**返回：**\n- 格式化后的JSON字符串和大小对比\n\n### 3. JSON压缩\n移除JSON中的空格和换行符，减小文件大小。\n\n**参数：**\n- json_string: 要压缩的JSON字符串\n\n**返回：**\n- 压缩后的JSON字符串和压缩比例\n\n### 4. 值提取\n使用JSONPath表达式从JSON中提取特定值。\n\n**参数：**\n- json_string: JSON字符串\n- json_path: JSONPath表达式\n\n**返回：**\n- 匹配的值列表和数量\n\n### 5. JSON合并\n合并两个JSON对象。\n\n**参数：**\n- json1: 第一个JSON字符串\n- json2: 第二个JSON字符串\n- strategy: 合并策略（update, deep_merge）\n\n**返回：**\n- 合并后的JSON对象\n\n### 6. JSON比较\n比较两个JSON对象的差异。\n\n**参数：**\n- json1: 第一个JSON字符串\n- json2: 第二个JSON字符串\n\n**返回：**\n- 详细的差异列表和比较结果\n\n### 7. 结构分析\n分析JSON数据的结构特征。\n\n**参数：**\n- json_string: 要分析的JSON字符串\n\n**返回：**\n- 结构信息，包括键数量、最大深度、数据类型统计等\n\n## 使用示例\n```python\n# 验证JSON\nresult = validate_json('{\"name\": \"张三\", \"age\": 30}')\n\n# 格式化JSON\nformatted = format_json('{\"name\":\"张三\",\"age\":30}', indent=4, sort_keys=True)\n\n# 压缩JSON\nminified = minify_json('{\\n  \"name\": \"张三\",\\n  \"age\": 30\\n}')\n\n# 提取值\nvalues = extract_values('{\"users\": [{\"name\": \"张三\"}, {\"name\": \"李四\"}]}', '$.users[*].name')\n\n# 合并JSON\nmerged = merge_json('{\"a\": 1}', '{\"b\": 2}', strategy=\"update\")\n\n# 比较JSON\ndiff = compare_json('{\"a\": 1, \"b\": 2}', '{\"a\": 1, \"b\": 3}')\n\n# 结构分析\nanalysis = analyze_json_structure('{\"users\": [{\"name\": \"张三\", \"age\": 30}]}')\n```\n\n## 特性\n1. 完整的JSON验证和错误定位\n2. 灵活的格式化选项\n3. 高效的压缩算法\n4. 强大的JSONPath查询支持\n5. 多种合并策略\n6. 详细的差异分析\n7. 深度结构分析\n8. 支持中文字符处理"
}